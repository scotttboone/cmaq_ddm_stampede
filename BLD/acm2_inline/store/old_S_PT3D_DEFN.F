C::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      MODULE S_PT3D_DEFN

C-----------------------------------------------------------------------
C Function: 3d point source emissions interface to DDM3D 

C Revision History:
C     25 Aug 2011 S.Napelenok: initial implementation from PT3D_DEFN

C-----------------------------------------------------------------------

      USE UDTYPES           ! implementation for multiple groups of stack input files
c     USE PT3D_DEFN, ONLY: PT3DEMIS

      IMPLICIT NONE

c     LOGICAL,                       SAVE :: PT3DEMIS   ! flag in-lining plume rise
c     INTEGER,                       SAVE :: NPTGRPS    ! no. pt src input file groups
c     REAL,             ALLOCATABLE, SAVE :: VDEMIS_PT( :,:,:,: ) ! 3D pt src non-PM emis
c     REAL,             ALLOCATABLE, SAVE :: PMEMIS_PT( :,:,:,: ) ! 3D pt src PM emis

C Scenario start
      INTEGER, PRIVATE,              SAVE :: SDATE = 0   ! Julian start date (YYYYDDD)
      INTEGER, PRIVATE,              SAVE :: STIME = 0   ! start time (HHMMSS)

C Output layer fractions, dimensioned NSRC, emlays, and for diagnostic file
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: LFRAC( :,: ) ! per source local layer fractn
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: TFRAC( : )   ! Temporary LFRAC

C debugging zplume
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: ZPLUM( :,: ) ! has to be 2D for play file

C Stack emissions for sources within domain
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: STKEM( : )   ! per source local stk emis
      INTEGER, PRIVATE,              SAVE :: EMLYRS       ! no. of emis layers

C Wildfire emissions source parameters
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: ACRES( : )   ! acres burned
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: BFLUX( : )   ! Briggs buoyancy flux

C Vertical coord values
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: VGLVSXG( : )

C Play report log
c     INTEGER, PRIVATE, ALLOCATABLE, SAVE :: RDEV( : )
C Play files source id file
c#ifdef srcid
c     INTEGER, PRIVATE, ALLOCATABLE, SAVE :: LDEV( : )
c#endif
C Plume rise info report files
c     CHARACTER( 13 ), PRIVATE, ALLOCATABLE, SAVE :: REPTNAME( : )
c     CHARACTER( 11 ), PRIVATE                    :: REPSTR
C Minimum layer for reporting srcs w/ high plumes
c     INTEGER, PRIVATE,              SAVE :: REP_LAYR

C Layer fractions matrix output files
c     CHARACTER(  16 ), PRIVATE, ALLOCATABLE, SAVE :: PLAYNAME( : )
C Layer fractions source id output files
c     CHARACTER(  16 ), PRIVATE, ALLOCATABLE, SAVE :: PLAY_SRCID_NAME( : )

C Get heights from GRID_CRO file, if true
c     LOGICAL, PRIVATE,              SAVE :: ZSTATIC = .TRUE.
C Write point source 3d emis diagnostic file, if true
c     LOGICAL, PRIVATE,              SAVE :: PT3DDIAG = .FALSE.
C Point source 3d emis diagnostic file names
!     CHARACTER( 16 ),               SAVE :: PT3DNAME
C Point source 3d emis diagnostic integral average write buffers
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: VDEMIS_BUF( :,:,:,: )
c     REAL,    PRIVATE, ALLOCATABLE, SAVE :: PMEMIS_BUF( :,:,:,: )
C Diagnostic file avg factor
c     REAL,    PRIVATE                    :: DIVFAC
C Write layer fractions diagnostic file, if true
c     LOGICAL, PRIVATE,              SAVE :: PT3DFRAC = .FALSE.

C Numerical flag for plume vertical spread method
c     INTEGER, PRIVATE,              SAVE :: IPVERT

C Stack parameters
c     TYPE( RARRY1 ), PRIVATE, ALLOCATABLE, SAVE :: STK_DM( : )
c     TYPE( RARRY1 ), PRIVATE, ALLOCATABLE, SAVE :: STK_HT( : )
c     TYPE( RARRY1 ), PRIVATE, ALLOCATABLE, SAVE :: STK_TK( : )
c     TYPE( RARRY1 ), PRIVATE, ALLOCATABLE, SAVE :: STK_VEL( : )

C Private Parameters:
c     CHARACTER(  10 ), PRIVATE, PARAMETER :: BLANK10 = ' '

C Private External Functions:
c     CHARACTER(   2 ), PRIVATE,  EXTERNAL :: CRLF

C cross-point layered grid file name
c     CHARACTER(  16 ), PRIVATE,     SAVE :: GC3NAME

C hourly stack emissions file names
c     CHARACTER(  16 ), PRIVATE, ALLOCATABLE, SAVE :: STKENAME( : )

c     CHARACTER( 120 ), PRIVATE           :: XMSG = ' '

      CONTAINS

C=======================================================================

         FUNCTION S_PT3D_INIT ( N_SPC_EMIS, EMLAYS, JDATE, JTIME, TSTEP,
     &                          FILELIST, GRPNUM )
     &                          RESULT ( SUCCESS )

C use N_SPC_EMIS+1 for non-accessed emissions

         USE GRID_CONF ! horizontal & vertical domain specifications
         USE STK_PRMS  ! stack groups file
         USE STK_EMIS  ! hourly point source emissions
         USE PMEM_DEFN ! defines emissions file(s) PM mapping
         USE PTMET     ! defines met variables used in plume rise
         USE PTBILIN   ! defines bi-linear interpolation from grid to pt src locations
         USE PTMAP     ! defines pt src species mapping to VDEMIS* arrays

         IMPLICIT NONE

C Includes:
         INCLUDE SUBST_IOPARMS   ! I/O parameters definitions
         INCLUDE SUBST_IOFDESC   ! file header data structure
!include         SUBST_IODECL    # I/O definitions and declarations
         INCLUDE SUBST_IODECL    ! I/O definitions and declarations
         INCLUDE SUBST_GC_EMIS   ! gas chem emis surrogate names & map table
         INCLUDE SUBST_AE_EMIS   ! aerosol emission surrogate names & map table
         INCLUDE SUBST_NR_EMIS   ! non-react emis surrogate names & map table
         INCLUDE SUBST_TR_EMIS   ! tracer emis surrogate names & map table
         INCLUDE SUBST_FILES_ID  ! file name parameters (for CTM_PT3D_DIAG)

C Arguments:
         INTEGER          N_SPC_EMIS ! total no. of model emissions species
         INTEGER          EMLAYS     ! number of emissions layers
         INTEGER          JDATE      ! Julian date (YYYYDDD)
         INTEGER          JTIME      ! time (HHMMSS)
         INTEGER          TSTEP      ! output time step
         CHARACTER( 16 )  FILELIST(2,9)
         INTEGER          GRPNUM
         LOGICAL          SUCCESS

C External Functions:
         INTEGER,         EXTERNAL :: SETUP_LOGDEV
         INTEGER,         EXTERNAL :: INDEX1, ENVINT, PROMPTFFILE
         LOGICAL,         EXTERNAL :: ENVYN
         CHARACTER( 16 ), EXTERNAL :: PROMPTMFILE

C Parameters:

C Local Variables:
         CHARACTER( 16 ), SAVE :: CTM_PT3DEMIS = 'CTM_PT3DEMIS' ! env var for in-line
                                                                ! 3d pt src emis
         CHARACTER( 16 )       :: PNAME = 'S_PT3D_INIT'  ! procedure name
         CHARACTER( 16 )       :: VNAME    ! variable name buffer
         CHARACTER( 16 ), SAVE, ALLOCATABLE :: STKGNAME( : ) ! stack groups file name

         INTEGER          METCCOLS       ! cross point grid number of columns
         INTEGER          METCROWS       ! cross point grid number of rows
         INTEGER          METDCOLS       ! dot point grid number of columns
         INTEGER          METDROWS       ! dot point grid number of rows
         INTEGER          IOS            ! i/o and allocate memory status
         INTEGER, SAVE :: NSTEPS = 1
         INTEGER          NDATE          ! next timestep file Julian date (YYYYDDD)
         INTEGER          NTIME          ! next timestep file time (HHMMSS)

         INTEGER          LOGDEV

         INTEGER I, J, K, L, M, N, S, SRC, V  ! counters and indices

         INTERFACE
            SUBROUTINE DELTA_ZS( EMLYRS, MY_NSRC, SRC_MAP, STKHT, ZF, ZSTK, DDZF )
               IMPLICIT NONE
               INTEGER, INTENT( IN )  :: EMLYRS, MY_NSRC
               INTEGER, INTENT( IN )  :: SRC_MAP( : )
               REAL,    INTENT( IN )  :: STKHT( : )
               REAL,    INTENT( IN )  :: ZF  ( EMLYRS,MY_NSRC )
               REAL,    INTENT( OUT ) :: ZSTK( EMLYRS,MY_NSRC )
               REAL,    INTENT( OUT ) :: DDZF( EMLYRS,MY_NSRC )
            END SUBROUTINE DELTA_ZS
         END INTERFACE

C-----------------------------------------------------------------------

         SUCCESS = .TRUE.

         LOGDEV = SETUP_LOGDEV()

C Get setting from environment variables
         EMLYRS = EMLAYS

         IPVERT = ENVINT( 'IPVERT', 'Method for vertical spread', 0, IOS )

C Cannot use default and cannot set to less than 4 because of limits of plume
C rise algorithm
         IF ( EMLYRS .LT. 4 ) THEN
            XMSG = 'Environment variable CTM_EMLAYS must be set to ' //
     &             'a number from 4 to the ' // CRLF() // BLANK10 //
     &             'number of layers in the meteorology inputs.'
            CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
            SUCCESS = .FALSE.; RETURN
         END IF

C get scenario timing

         SDATE = ENVINT( 'LAYP_STDATE',
     &                   'Scenario Starting Date (YYYYDDD)',
     &                    2001188, IOS )

         STIME = ENVINT( 'LAYP_STTIME',
     &                   'Scenario Starting Time (HHMMSS)',
     &                    0, IOS )

         NSTEPS = ENVINT( 'LAYP_NSTEPS',
     &                    'Scenario Run Duration (integer steps)',
     &                     24, IOS )

         JDATE = SDATE
         JTIME = STIME

C open met files


C Get grid parameters from 3-d cross-point met file and store header information.
C Use time parameters for time defaults.
c        CALL RETRIEVE_IOAPI_HEADER( MC3NAME, JDATE, JTIME )

C Initialize reference grid with met file
C (declared and stored in PTBILIN module)
c        XCELLCG = XCELL3D
c        YCELLCG = YCELL3D
c        METCCOLS = NCOLS3D
c        METCROWS = NROWS3D
c        METCXORIG = XORIG3D
c        METCYORIG = YORIG3D
!!!!!^^^^^^^!!!! THESE NEED TO BE CHECKED AGAINST GRIDDESC

C Determine whether height information is time dependent or time independent.
C Non-hydrostatic is time-independent and hydrostatic is time-dependent.
         SELECT CASE( VGTYP_GD )
            CASE ( VGSGPH3, VGHVAL3, VGWRFEM )
               ZSTATIC = .FALSE.
            CASE ( VGSGPN3 )
               ZSTATIC = .TRUE.
            CASE DEFAULT
               WRITE( XMSG,94010 ) 'Cannot process vertical ' //
     &                             'coordinate type', VGTYP_GD
               CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
               SUCCESS = .FALSE.; RETURN
         END SELECT

         IF ( ZSTATIC ) THEN
            GC3NAME = PROMPTMFILE( 
     &                   'Enter name for CROSS-POINT LAYERED GRID file',
     &                   FSREAD3, 'GRID_CRO_3D', PNAME )
         END IF

C Get grid parameters from 3-d cross-point met file and store header information.
C (declared and stored in PTBILIN module)
         CALL RETRIEVE_IOAPI_HEADER( MD3NAME, JDATE, JTIME )
         XCELLDG = XCELL3D
         YCELLDG = YCELL3D
         METDXORIG = XORIG3D
         METDYORIG = YORIG3D
!!!!!!^^^^^^^!!!! THESE NEED TO BE CHECKED AGAINST GRIDDESC
         METDCOLS = NCOLS3D
         METDROWS = NROWS3D

C Compare number of meteorology layers to number of emissions layers
         IF ( EMLYRS .LE. NLAYS ) THEN
            WRITE( XMSG,94010 ) 'NOTE: The number of emission layers ' //
     &                          'is', EMLYRS, ', and the maximum ' // CRLF()
     &                          // BLANK10 // 'possible layers is', NLAYS
            CALL M3MSG2( XMSG )
         ELSE
            WRITE( XMSG,94010 ) 'Resetting number of emission layers ' //
     &                          'from', EMLYRS, 'to number of ' // CRLF() //
     &                      BLANK10 // 'layers in the meteorology file,', NLAYS
            CALL M3WARN( PNAME, JDATE, JTIME, XMSG )
            EMLYRS = NLAYS
         END IF

         ALLOCATE( VGLVSXG( 0:MXLAYS3 ), STAT = IOS )
         CALL CHECKMEM( IOS, 'VGLVSXG', PNAME )

C Store local layer information
         J = LBOUND( VGLVS3D, 1 )   ! F90 array intrinsic
         VGLVSXG( 0 ) = VGLVS3D( J )
         DO L = 1, NLAYS
            J = J + 1
            VGLVSXG( L ) = VGLVS3D( J )
         END DO

         IF ( NSTEPS .GT. MXREC3D ) THEN
            WRITE( XMSG,94010 ) 
     &               'Requested output time steps > those on met file '
     &                          // CRLF() // BLANK10 // 'reset to ', MXREC3D
            NSTEPS = MXREC3D
         END IF

C Get stack data
         ALLOCATE ( STKGNAME( NPTGRPS ), STAT = IOS )   ! stk parms files array
         CALL CHECKMEM( IOS, 'STKGNAME', PNAME )
         STKGNAME = ' '   ! array

         DO N = 1, NPTGRPS
            WRITE( VNAME,'( "STK_GRPS_",I2.2 )' ) N
            STKGNAME( N ) = 
     &                  PROMPTMFILE( 'Enter name for stack groups file',
     &                                   FSREAD3, VNAME, PNAME )
         END DO

         IF ( .NOT. STK_PRMS_INIT( STKGNAME ) ) THEN
            XMSG = 'Could not initialize stack parameters'
            CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
            SUCCESS = .FALSE.; RETURN
         END IF

c#ifdef srcid
c         IF ( PT3DFRAC ) THEN
c            DO N = 1, NPTGRPS
c               WRITE( LDEV( N ),93053 ) N, MY_NSRC( N ), MY_STRT_SRC( N )
c               DO S = 1, MY_NSRC( N )
c                  WRITE( LDEV( N ),93057 ) S, SOURCE( N )%ARRY( S ) + MY_STRT_SRC( N ) - 1
c               END DO
c            END DO
c         END IF
c#endif

C Initialize stack emissions data
         ALLOCATE ( STKENAME( NPTGRPS ), STAT = IOS )   ! stk emis files array
         CALL CHECKMEM( IOS, 'STKENAME', PNAME )
         STKENAME = ' '   ! array

         DO N = 1, NPTGRPS
            WRITE( VNAME,'( "STK_EMIS_",I2.2 )' ) N
            STKENAME( N ) = 
     &               PROMPTMFILE( 'Enter name for stack emissions file',
     &                                   FSREAD3, VNAME, PNAME )
         END DO

         IF ( .NOT. STK_EMIS_INIT( STKENAME, JDATE, JTIME ) ) THEN
            XMSG = 'Could not initialize stack parameters'
            CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
            SUCCESS = .FALSE.; RETURN
         END IF

         DO N = 1, NPTGRPS
            IF ( NSRC( N ) .NE. NSRC_EMIS( N ) ) THEN
               WRITE( LOGDEV,* ) 'NSRC vs. NSRC_EMIS:', N, NSRC( N ), NSRC_EMIS( N )
               XMSG = 'No. of sources for stack files don''t match'
               CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
               SUCCESS = .FALSE.; RETURN
            END IF
         END DO

         IF ( .NOT. PTMAP_INIT( NPTGRPS ) ) THEN
            XMSG = 'Could not get point source mappings'
            CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
            SUCCESS = .FALSE.; RETURN
         END IF

         ALLOCATE ( VDEMIS_PT( MY_NCOLS,MY_NROWS,EMLYRS,N_SPC_PTEM ), STAT = IOS )
         CALL CHECKMEM( IOS, 'VDEMIS_PT', PNAME )
         VDEMIS_PT = 0.0   ! array

         ALLOCATE ( PMEMIS_PT( MY_NCOLS,MY_NROWS,EMLYRS,N_SPC_PTPM ), STAT = IOS )
         CALL CHECKMEM( IOS, 'PMEMIS_PT', PNAME )
         PMEMIS_PT = 0.0   ! array

C Set up and open 3d point source emissions diagnostic file?
         IF ( PT3DDIAG ) THEN
            NDATE = SDATE; NTIME = STIME
            CALL NEXTIME( NDATE, NTIME, TSTEP ) ! advance one output tstep
            CALL OPPT3D_DIAG( CTM_PT3D_DIAG, NDATE, NTIME, TSTEP, EMLYRS,
     &                        N_SPC_PTEM, STKEM_NAME, N_SPC_PTPM, STKPM_NAME )
            ALLOCATE ( VDEMIS_BUF( MY_NCOLS,MY_NROWS,EMLYRS,N_SPC_PTEM ), STAT = IOS )
            CALL CHECKMEM( IOS, 'VDEMIS_BUF', PNAME )
            VDEMIS_BUF = 0.0   ! array
            ALLOCATE ( PMEMIS_BUF( MY_NCOLS,MY_NROWS,EMLYRS,N_SPC_PTPM ), STAT = IOS )
            CALL CHECKMEM( IOS, 'PM_EMIS_BUF', PNAME )
            PMEMIS_BUF = 0.0   ! array
            WRITE( LOGDEV,'(/5X, A /5X, A )' )
     &                'Recording 3d point source emissions diagnostics',
!    &                'as an integral average over the output timestep'
     &                'as a linear average over the output timestep'
         END IF

         IF ( .NOT. PTMET_INIT ( NPTGRPS, EMLYRS ) ) THEN
            XMSG = 'Could not initialize stack met data'
            CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
            SUCCESS = .FALSE.; RETURN
         END IF

         ALLOCATE( TFRAC( EMLYRS ), STAT = IOS )
         CALL CHECKMEM( IOS, 'TFRAC', PNAME )
         TFRAC = 0.0   ! array

         ALLOCATE( STK_DM( NPTGRPS ), STAT = IOS )
         CALL CHECKMEM( IOS, 'STK_DM', PNAME )

         ALLOCATE( STK_HT( NPTGRPS ), STAT = IOS )
         CALL CHECKMEM( IOS, 'STK_HT', PNAME )

         ALLOCATE( STK_TK( NPTGRPS ), STAT = IOS )
         CALL CHECKMEM( IOS, 'STK_TK', PNAME )

         ALLOCATE( STK_VEL( NPTGRPS ), STAT = IOS )
         CALL CHECKMEM( IOS, 'STK_VEL', PNAME )

         DO N = 1, NPTGRPS

C Allocate and set stack parameters

            ALLOCATE( STK_DM( N )%ARRY( MY_NSRC( N ) ), STAT = IOS )
            CALL CHECKMEM( IOS, 'STK_DM', PNAME )
            STK_DM( N )%ARRY = 0.0   ! 1D array
            STK_DM( N )%LEN = MY_NSRC( N )

            ALLOCATE( STK_HT( N )%ARRY( MY_NSRC( N ) ), STAT = IOS )
            CALL CHECKMEM( IOS, 'STK_HT', PNAME )
            STK_HT( N )%ARRY = 0.0   ! 1D array
            STK_HT( N )%LEN = MY_NSRC( N )

            ALLOCATE( STK_TK( N )%ARRY( MY_NSRC( N ) ), STAT = IOS )
            CALL CHECKMEM( IOS, 'STK_TK', PNAME )
            STK_TK( N )%ARRY = 0.0   ! 1D array
            STK_TK( N )%LEN = MY_NSRC( N )

            ALLOCATE( STK_VEL( N )%ARRY( MY_NSRC( N ) ), STAT = IOS )
            CALL CHECKMEM( IOS, 'STK_VEL', PNAME )
            STK_VEL( N )%ARRY = 0.0   ! 1D array
            STK_VEL( N )%LEN = MY_NSRC( N )

            DO S = 1, MY_NSRC( N )
               SRC = SOURCE( N )%ARRY( S )
               STK_DM( N )%ARRY( S )  = STKDIAM( N )%ARRY( SRC )
               STK_HT( N )%ARRY( S )  = STKHT( N )%ARRY( SRC )
               STK_TK( N )%ARRY( S )  = STKTK( N )%ARRY( SRC )
               STK_VEL( N )%ARRY( S ) = STKVEL( N )%ARRY( SRC )
            END DO

C If wildfire, allocate and fire parameters (assumes only one file group)
            IF ( FIREFLAG( N ) ) THEN

               ALLOCATE( ACRES( MY_NSRC( N ) ), STAT = IOS )
               CALL CHECKMEM( IOS, 'ACRES', PNAME )
               ACRES = 0.0   ! 1D array

               DO S = 1, MY_NSRC( N )
                  SRC = SOURCE( N )%ARRY( S )
                  ACRES( S ) = ACRES_BURNED( SRC )
               END DO

               ALLOCATE( BFLUX( MY_NSRC( N ) ), STAT = IOS )
               CALL CHECKMEM( IOS, 'BFLUX', PNAME )
               BFLUX = 0.0   ! 1D array

            END IF

         END DO

         IF ( .NOT. PTBILIN_INIT ( NPTGRPS ) ) THEN
            XMSG = 
     &      'Could not initialize stack met bilinear interpolation data'
            CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
            SUCCESS = .FALSE.; RETURN
         END IF

         IF ( ZSTATIC ) THEN ! Read time-independent ZF and ZH for non-hydrost Met data

            DO N = 1, NPTGRPS

C Compute per-source heights

C Get un-gridding matrices for cross and dot point met data
               CALL RETRIEVE_IOAPI_HEADER( GC3NAME, JDATE, JTIME )
               CALL READGC3 ( 'X3HT0M', SDATE, STIME, XBUF )
               CALL BMATVEC( METCGRID, MY_NSRC( N ), EMLYRS,
     &                       BILIN_DATA( N )%NX,
     &                       BILIN_DATA( N )%CX,
     &                       XBUF, PTMET_DATA( N )%ZH )

               CALL READGC3 ( 'X3HT0F', SDATE, STIME, XBUF )
               CALL BMATVEC( METCGRID, MY_NSRC( N ), EMLYRS,
     &                       BILIN_DATA( N )%NX,
     &                       BILIN_DATA( N )%CX,
     &                       XBUF, PTMET_DATA( N )%ZF )

C Compute ZSTK, DDZF
               CALL DELTA_ZS( EMLYRS, MY_NSRC( N ),
     &                        SOURCE( N )%ARRY, STKHT( N )%ARRY,
     &                        PTMET_DATA( N )%ZF,
     &                        PTMET_DATA( N )%ZSTK,
     &                        PTMET_DATA( N )%DDZF )

            END DO   ! NPTGRPS

         END IF   ! ZSTATIC

         SUCCESS = .TRUE.; RETURN

93053    FORMAT("#  Src Id's for play file",I2,', with',I10,
     &          ' total sources',", and my_strt_src:", I10 )
93057    FORMAT( I6, I8 )
94010    FORMAT( 12( A, :, I8, :, 1X ) )

         END FUNCTION S_PT3D_INIT

C=======================================================================

         SUBROUTINE GET_S_PT3D_EMIS ( JDATE, JTIME, TSTEP )

C-----------------------------------------------------------------------

C Time step part of laypoint

         USE GRID_CONF ! horizontal & vertical domain specifications
         USE STK_PRMS  ! stack groups file
         USE STK_EMIS  ! hourly point source emissions
         USE PMEM_DEFN ! defines emissions file(s) PM mapping
         USE PTMET, P_D => PTMET_DATA
         USE PTMAP     ! defines pt src species mapping to VDEMIS* arrays
         USE SUBST_MODULES         ! stenex
!        USE SUBST_UTIL_MODULE     ! stenex

         IMPLICIT NONE

C Includes:
         INCLUDE SUBST_IOPARMS   ! I/O parameters definitions
!        INCLUDE SUBST_IODECL    ! I/O definitions and declarations
#include         SUBST_IODECL    # I/O definitions and declarations
         INCLUDE SUBST_CONST     ! physical and mathematical constants
         INCLUDE SUBST_FILES_ID  ! file name parameters (for CTM_PT3D_DIAG)

C Arguments:
         INTEGER               :: JDATE, JTIME
         INTEGER, INTENT( IN ) :: TSTEP( 2 )

C Parameters:
         REAL,            PARAMETER :: USTARMIN = 0.1   ! Min valid value for USTAR
         REAL,            PARAMETER :: CONVPA = 1.0E-2  ! convert Pa to mb
         REAL,            PARAMETER :: BTU2M4PS3 = 9.2752E-03 ! convert BTU/s to m**4/s**3
         REAL,            PARAMETER :: BFACPHR = BTU2M4PS3 / 3600.0 ! m**4/s**3 per hour
                                 ! assumes heat flux from file pt src file is in BTU/hr

C External functions:
         INTEGER,         EXTERNAL :: SETUP_LOGDEV, TIME2SEC, SEC2TIME, SECSDIFF
         CHARACTER( 10 ), EXTERNAL :: HHMMSS
         LOGICAL,         EXTERNAL :: WRITE3_DISTR   ! calls WRITE3 directly

C Local variables:
         INTEGER          CDATE      ! previous step start date
         INTEGER          CTIME      ! previous step start time
         INTEGER, SAVE :: LDATE = 0  ! previous date
         INTEGER          LBOT       ! layer containing plume bottom
         INTEGER          LTOP       ! layer containing plume top
         INTEGER          LPBL       ! first L: ZF(L) above mixing layer - ONLY for REPORT
         INTEGER          LSTK       ! first L: ZF(L) > STKHT
         INTEGER          SRC        ! source pointer in this proc sub-domain
         REAL             LFRC       ! intermediate LFRAC
         REAL             MV         ! mininum LFRAC 
         REAL             PSFC       ! surface pressure [Pa]
         REAL             TSTK       ! temperature at top of stack [K]
         REAL             TSUM       ! tmp layer frac sum for renormalizing
         REAL             WSTK       ! wind speed  at top of stack [m/s]
         REAL             ZBOT       ! plume bottom elevation [m]
         REAL             ZTOP       ! plume top    elevation [m]
         REAL             ZDIFF      ! ZTOP - ZBOT
         REAL             DDZ        ! 1 / ZDIFF
         REAL             ZPLM       ! plume centerline height above stack [m]
         REAL             USTMP      ! temp storage for ustar [m/s]
         REAL             HFLX       ! converted heat flux
         REAL             BESIZE     ! effective size of the fire buoyant core
         REAL             SFRACT     ! smoldering fraction size (1-BESIZE)

         CHARACTER(  8 ) :: CINT     ! integer to character buffer for warning messages
         CHARACTER( 16 ) :: PNAME = 'GET_PT3D_EMIS'   ! procedure name
         CHARACTER( 16 ) :: VNAME    ! variable name buffer

         INTEGER          IOS        ! i/o and allocate memory status
         INTEGER          L, S, V    ! counters
         INTEGER          C, R, I, J, N

         INTEGER, SAVE :: WSTEP = 0
         INTEGER          WDATE, WTIME
         LOGICAL, SAVE :: WRTIME
         INTEGER, SAVE :: NTICS = 0      ! no. of substeps within an output tstep
         LOGICAL, SAVE :: FIRSTIME = .TRUE.
         INTEGER, SAVE :: LOGDEV

D        real mxzplm

C-----------------------------------------------------------------------

         IF ( FIRSTIME ) THEN
            FIRSTIME = .FALSE.
            LOGDEV = SETUP_LOGDEV()
         END IF

C For each time step, compute the layer fractions...

c        WRITE( XMSG,'(A, I7.6)' )
c    &   'Calculating emissions point source layer fractions for', JTIME
c        WRITE( LOGDEV,* ) ' '
c        CALL M3MSG2( XMSG )

c        IF ( LDATE .NE. JDATE ) THEN  ! write day and date to stdout & XMSG
c           CALL WRDAYMSG( JDATE, XMSG )
c           LDATE = JDATE
c           WRITE( LOGDEV,'(9X, "at time ", A)' ) HHMMSS( JTIME )
c        END IF
c        WRTIME = .FALSE.
c        WSTEP = WSTEP + TIME2SEC( TSTEP( 2 ) )
c        IF ( WSTEP .GE. TIME2SEC( TSTEP( 1 ) ) ) THEN
c           WDATE = JDATE; WTIME = JTIME
c           CALL NEXTIME( WDATE, WTIME, TSTEP( 2 ) )
c           CALL CURRSTEP( WDATE, WTIME, SDATE, STIME, TSTEP( 1 ), CDATE, CTIME )
c           WDATE = CDATE; WTIME = CTIME
c           WSTEP = 0
c           WRTIME = .TRUE.
c           DO N = 1, NPTGRPS
c              IF ( RDEV( N ) .GT. 0 ) THEN    ! write day, date and time to report file
c                 WRITE( CINT,'( I8 )' ) REP_LAYR
c                 CALL WRDAYMSG( WDATE, XMSG )
c                 XMSG = XMSG( 1:LEN_TRIM( XMSG ) )
c    &                    // ' at time ' // HHMMSS( WTIME )
c    &                    // 'for ltop .ge. ' // TRIM( ADJUSTL( CINT ) )
c                 WRITE( RDEV( N ),93000 ) XMSG( 1:LEN_TRIM( XMSG ) )
c              END IF
c           END DO
c        END IF

C Convert pt source met data to bi-linear interpolated data
         CALL PTMET_CONVT( JDATE, JTIME, NPTGRPS, EMLYRS, ZSTATIC )

         VDEMIS_PT = 0.0   ! array assignment
         PMEMIS_PT = 0.0   ! array assignment

         DO N = 1, NPTGRPS

            ALLOCATE( STKEM( NVARS_EMIS( N ) ), STAT = IOS )
            CALL CHECKMEM( IOS, 'STKEM', PNAME )
            STKEM = 0.0   ! 1-D array assignment
            IF ( PT3DFRAC ) THEN   ! Store layer fractions
               ALLOCATE( LFRAC( MY_NSRC( N ),EMLYRS ), STAT = IOS )
               CALL CHECKMEM( IOS, 'LFRAC', PNAME )
               ALLOCATE( ZPLUM( MY_NSRC( N ),EMLYRS ), STAT = IOS )
               CALL CHECKMEM( IOS, 'ZPLUM', PNAME )
               LFRAC = 0.0   ! 2-D array - Initialize layer fraction
               ZPLUM = 0.0   ! 2-D array - Initialize plume centroid height
            END IF

            IF ( MY_NSRC( N ) .LE. 0 ) THEN
               IF ( ALLOCATED( STKEM ) ) DEALLOCATE( STKEM )
               IF ( PT3DFRAC ) THEN
                  IF ( ALLOCATED( LFRAC ) ) DEALLOCATE( LFRAC )
                  IF ( ALLOCATED( ZPLUM ) ) DEALLOCATE( ZPLUM )
               END IF
               CYCLE
            END IF

C Ensure that the model and stack groups emissions timestamp dates stay synchronized
            IF ( SECSDIFF( JDATE,JTIME, STKDATE( N ),JTIME ) .NE. SYNCOFF( N ) ) THEN
               STKDATE( N ) = SEC2TIME( TIME2SEC( JDATE ) + SYNCOFF( N ) )
            END IF

            DO V = 1, NVARS_EMIS( N )
               VNAME = STKSPC( N )%ARRY( V )
               IF ( .NOT. INTERPX( STKENAME( N ), VNAME, PNAME,
     &                             1,1, MY_STRT_SRC( N ),MY_END_SRC( N ), 1,1,
     &                             STKDATE( N ), JTIME,
     &                             STKEMIS( N )%ARRY( 1,V ) ) ) THEN
                  XMSG = 'Could not read ' // TRIM( VNAME ) //
     &                   ' from ' // TRIM( STKENAME( N ) )
                  CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
               END IF
            END DO

            IF ( FIREFLAG( N ) ) THEN
               DO V = 1, NVARS_FIRE
                  VNAME = FIRENAM( 1 )%ARRY( V )
                  IF ( .NOT. INTERPX( STKENAME( N ), VNAME, PNAME,
     &                                1,1, MY_STRT_SRC( N ),MY_END_SRC( N ), 1,1,
     &                                STKDATE( N ), JTIME,
     &                                FIREVAR( 1 )%ARRY( 1,V ) ) ) THEN
                     XMSG = 'Could not read ' // TRIM( VNAME ) //
     &                      ' from ' // TRIM( STKENAME( N ) )
                     CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
                  END IF
               END DO
               DO S = 1, MY_NSRC( N )
                  SRC = SOURCE( N )%ARRY( S )
                  BFLUX( S ) = FIREVAR( 1 )%ARRY( SRC,1 ) * BTU2M4PS3
               END DO
            END IF

C Loop through sources and compute plume rise

D           mxzplm = 0.0

            DO S = 1, MY_NSRC( N )

               IF ( FIREFLAG( N ) ) THEN
                  IF ( BFLUX( S ) .LE. 0.0 ) THEN
                     TFRAC( 1 ) = 1.0
                     TFRAC( 2:EMLYRS ) = 0.0
                     LTOP = 1
                     GO TO 201
                  END IF
               END IF

               P_D( N )%ZZF( 0 ) = 0.0
               P_D( N )%ZZF( 1:EMLYRS ) = P_D( N )%ZF( 1:EMLYRS,S )  ! array of layers

C Get pressures: Use SIGMA values and surface pres. p=sigma*(psfc-ptop)+ptop
               PSFC = P_D( N )%PRSFC( S )
               DO L = 0, EMLYRS
                  P_D( N )%PRESF( L ) = ( VGLVSXG( L ) * ( PSFC - VGTOP_GD )
     &                                +   VGTOP_GD ) * CONVPA
               END DO

C Set surface pressure (convert to mb from Pa)
               PSFC = CONVPA * PSFC

C Compute derived met vars needed before layer assignments
               CALL PREPLM( FIREFLAG( N ), EMLYRS,
     &                      P_D( N )%HMIX( S ), STK_HT( N )%ARRY( S ), PSFC,
     &                      P_D( N )%TSFC( S ),    P_D( N )%DDZF( 1,S ),
     &                      P_D( N )%QV( 1,S ),    P_D( N )%TA( 1,S ),
     &                      P_D( N )%UWIND( 1,S ), P_D( N )%VWIND( 1,S ),
     &                      P_D( N )%ZH( 1,S ),    P_D( N )%ZF( 1,S ),
     &                      P_D( N )%PRESF( 0 ), LSTK, LPBL, TSTK, WSTK,
     &                      P_D( N )%DTHDZ,        P_D( N )%WSPD )

C Trap USTAR at a minimum realistic value
               USTMP = MAX( P_D( N )%USTAR( S ), USTARMIN )

C Convert heat flux (watts/m2 to m K /s )
               HFLX = P_D( N )%HFX( S ) / ( CPD * P_D( N )%DENS( 1,S ) )

               IF ( .NOT. FIREFLAG( N ) ) THEN
                  CALL PLMRIS( EMLYRS, LSTK, HFLX, P_D( N )%HMIX( S ),
     &                         STK_DM( N )%ARRY( S ), STK_HT( N )%ARRY( S ),
     &                         STK_TK( N )%ARRY( S ), STK_VEL( N )%ARRY( S ),
     &                         TSTK, USTMP,
     &                         P_D( N )%DTHDZ,     P_D( N )%TA( 1,S ),
     &                         P_D( N )%WSPD,      P_D( N )%ZZF( 0 ),
     &                         P_D( N )%ZH( 1,S ), P_D( N )%ZSTK( 1,S ),
     &                         WSTK, ZPLM )
               ELSE
                  CALL FIRE_PLMRIS( EMLYRS, LSTK, HFLX, P_D( N )%HMIX( S ),
     &                         BFLUX( S ),
     &                         TSTK, USTMP,
     &                         P_D( N )%DTHDZ,     P_D( N )%TA( 1,S ),
     &                         P_D( N )%WSPD,      P_D( N )%ZZF( 0 ),
     &                         WSTK, ZPLM )
               END IF

D              if ( zplm .gt. mxzplm ) mxzplm = zplm

C Determine the bottom and top heights of the plume.
               IF ( IPVERT .EQ. 0 ) THEN
C Default Turner approach.  Plume thickness = amount of plume rise
C Plume rise DH = ZPLM minus the stack height STKHT
                  IF ( FIREFLAG( N ) ) THEN
                     ZTOP = 1.5 * ZPLM 
                     ZBOT = 0.5 * ZPLM
                  ELSE
                     ZTOP = STK_HT( N )%ARRY( S )
     &                    + 1.5 * ( ZPLM - STK_HT( N )%ARRY( S ) )
                     ZBOT = STK_HT( N )%ARRY( S )
     &                    + 0.5 * ( ZPLM - STK_HT( N )%ARRY( S ) )
                  END IF
               ELSE
C Alternative method to compute plume top/bot heights
                  CALL PLSPRD( P_D( N )%DTHDZ, P_D( N )%ZZF, EMLYRS,
     &                         ZPLM, ZTOP, ZBOT )
               END IF

C Set up for computing plume fractions, assuming uniform distribution in pressure
C (~mass concentration -- minor hydrostatic assumption) from bottom to top.

               IF ( ZTOP .LT. STK_HT( N )%ARRY( S ) ) THEN
                  WRITE( CINT,'( I8 )' ) S
                  WRITE( XMSG,94010 )'ERROR: Top of plume is less than '
     &                                // 'top of stack for source:' // CINT
                  CALL M3MESG( XMSG )
                  WRITE( LOGDEV,* ) '    Zbot: ', ZBOT, ' Ztop: ', ZTOP
                  WRITE( LOGDEV,* ) '    Stack Top: ', STK_HT( N )%ARRY( S ),
     &                              ' Plume Top: ', ZPLM
                  CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
               END IF

C Allocate plume to layers (compute layer plume fractions)

!              CALL POSTPLM( EMLYRS, ZBOT, ZTOP, PRESF, ZZF, TA( 1,S ), ZH( 1,S ),
!    &                       LTOP, TFRAC )

C Compute LBOT, LTOP such that
C  ZZF( LBOT-1 ) <= ZBOT < ZZF( LBOT ) and
C  ZZF( LTOP-1 ) <= ZTOP < ZZF( LTOP )

               DO L = 1, EMLYRS - 1
                  IF ( ZBOT .LE. P_D( N )%ZZF( L ) ) THEN
                     LBOT = L
                     GO TO  122
                  ELSE
                     TFRAC( L ) = 0.0             ! fractions below plume
                  END IF
               END DO
               LBOT = EMLYRS                      !  fallback


122            CONTINUE                           !  loop exit:  bottom found at LBOT

               IF ( ZTOP .LE. P_D( N )%ZZF( LBOT ) ) THEN  ! plume in this layer

                  TFRAC( LBOT ) = 1.0
                  LTOP = LBOT

                  DO L = LBOT + 1, EMLYRS         ! fractions above plume
                     TFRAC( L ) = 0.0
                  END DO

               ELSE IF ( LBOT .EQ. EMLYRS ) THEN  ! plume above top layer

                  TFRAC( LBOT ) = 1.0

                  DO L = 1, EMLYRS - 1            ! fractions below plume
                     TFRAC( L ) = 0.0
                  END DO

               ELSE                               ! plume crosses layers

                  DO L = LBOT + 1, EMLYRS
                     IF ( ZTOP .LE. P_D( N )%ZZF( L ) ) THEN
                        LTOP = L
                        GO TO 126
                     END IF
                  END DO
                  LTOP = EMLYRS                   !  fallback

126               CONTINUE

                  ZDIFF = ZTOP - ZBOT
                  IF ( ZDIFF .GT. 0.0 ) THEN

                     DDZ  = 1.0 / ZDIFF
                     TFRAC( LBOT ) = DDZ * ( P_D( N )%ZZF( LBOT ) - ZBOT )
                     TFRAC( LTOP ) = DDZ * ( ZTOP - P_D( N )%ZZF( LTOP-1 ) )

                  ELSE   ! ZDIFF .le. 0

                     WRITE( CINT,'( I8 )' ) S
                     WRITE( XMSG,94020 )
     &                  'Infinitely small plume created for source:,'
     &                  // CINT // CRLF() // BLANK10
     &                  // 'All emissions put in first layer.'
                     CALL M3WARN( PNAME, JDATE, JTIME, XMSG )
                     LBOT = 1; LTOP = 1
                     TFRAC( LBOT ) = 1.0

                  END IF

                  DO L = LBOT + 1, LTOP - 1       ! layers in plume
                     TFRAC( L ) = DDZ * ( P_D( N )%ZZF( L ) - P_D( N )%ZZF( L-1 ) )
                  END DO

                  DO L = LTOP + 1, EMLYRS         ! fractions above plume
                     TFRAC( L ) = 0.0
                  END DO

               END IF

C If layer fractions are negative, put in the first layer
               MV = MINVAL( TFRAC( 1:EMLYRS ) )
               IF ( MV .LT. 0 ) THEN

                  WRITE( CINT,'( I8 )' ) S
                  WRITE( XMSG,94010 ) 
     &                     'WARNING: One or more negative plume '
     &                     // 'fractions found for source:' // CINT
     &                     // CRLF() // BLANK10 // 'Plume reset to '
     &                     // 'put all emissions in surface layer.'
                  CALL M3MESG( XMSG )

                  TFRAC( 1 ) = 1.0
                  TFRAC( 2:EMLYRS ) = 0.0

               END IF

               IF ( FIREFLAG( N ) ) THEN
C If source is a fire, adjust for fire smoldering effects (include fractions below LBOT)
C calculate smoldering fraction:

                  IF ( ACRES( S ) .NE. 0.0 ) THEN
                     BESIZE = 0.0703 * LOG( ACRES( S ) ) + 0.3
                     BESIZE = MIN( BESIZE, 1.0 )
                     SFRACT = 1.0 - BESIZE
                  ELSE
                     SFRACT = 1.0
                     write( logdev,* ) "we can't get here: ", n, s
                  END IF

                  ZDIFF = ZBOT - P_D( N )%ZZF( 0 )   ! Note: ZDIFF redefined
                  IF ( ZDIFF .GT. 0.0 ) THEN
                     DDZ  = 1.0 / ZDIFF
                     DO L = 1, LBOT - 1
                       TFRAC( L ) = DDZ * ( P_D( N )%ZZF( L ) - P_D( N )%ZZF( L-1 ) )
     &                            * SFRACT
                     END DO
                     TFRAC( LBOT ) = TFRAC( LBOT )
     &                             + ( DDZ * ( ZBOT - P_D( N )%ZZF( LBOT-1 ) )
     &                               - TFRAC( LBOT ) ) * SFRACT
                  ELSE   ! LBOT = 1
!                    TFRAC( 1:LBOT-1 ) = 0.0
                     TFRAC( LBOT ) = TFRAC( LBOT ) * ( 1.0 - SFRACT )
                  END IF

                  DO L = LBOT + 1, LTOP
                     TFRAC( L ) = TFRAC( L ) * ( 1.0 - SFRACT )
                  END DO

               END IF

201            CONTINUE

C Apportion emissions to the layers

               SRC = SOURCE( N )%ARRY( S )
               STKEM( : ) = STKEMIS( N )%ARRY( SRC,: )   ! array of species

               C = MY_STKCOL( N )%ARRY( S ); R = MY_STKROW( N )%ARRY( S )
               DO L = 1, EMLYRS
                  LFRC = TFRAC( L )
                  IF ( LFRC .LE. 0.0 ) CYCLE

                  DO V = 1, STKEM_MAP( N )%LEN
                     I = GAS_MAP( N )%ARRY( V )
                     J = STKEM_MAP( N )%ARRY( V )
                     VDEMIS_PT( C,R,L,I ) = VDEMIS_PT( C,R,L,I )
     &                                    + LFRC * STKEM( J )
                  END DO
                  DO V = 1, STKPM_MAP( N )%LEN
                     I = PM_MAP( N )%ARRY( V )
                     J = STKPM_MAP( N )%ARRY( V )
                     PMEMIS_PT( C,R,L,I ) = PMEMIS_PT( C,R,L,I )
     &                                    + LFRC * STKEM( J )
                  END DO

               END DO

               IF ( PT3DFRAC ) THEN   ! Store layer fractions
                  LFRAC( S,1:EMLYRS ) = TFRAC( 1:EMLYRS )  ! array
                  ZPLUM( S,1 ) = ZPLM
               END IF

C Possible report to REPRTLAY
               IF ( LTOP .GE. REP_LAYR .AND. RDEV( N ) .GT. 0 .AND. WRTIME ) THEN
                  WRITE( RDEV( N ),93048 ) S, STK_HT( N )%ARRY( S ), LPBL,
     &                                     LBOT, LTOP, STK_VEL( N )%ARRY( S ), WSTK,
     &                                     STK_TK( N )%ARRY( S ), TSTK
               END IF

            END DO    ! end loop on sources S

c           IF ( PT3DFRAC .AND. WRTIME ) THEN     ! Write out layer fractions
c              IF ( .NOT. WRITE3_DISTR( PLAYNAME( N ), 'LFRAC', WDATE, WTIME,
c    &                                  MY_NSRC( N ), EMLYRS, LFRAC ) ) THEN
c                 XMSG = 'Error writing "LFRAC" to file "' //
c    &                    PLAYNAME( N )( 1:LEN_TRIM( PLAYNAME( N ) ) ) // '."'
c                 CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
c              END IF
c              IF ( .NOT. WRITE3_DISTR( PLAYNAME( N ), 'ZPLUME', WDATE, WTIME,
c    &                                  MY_NSRC( N ), EMLYRS, ZPLUM ) ) THEN
c                 XMSG = 'Error writing "ZPLUM" to file "' //
c    &                    PLAYNAME( N )( 1:LEN_TRIM( PLAYNAME( N ) ) ) // '."'
c                 CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
c              END IF
c           WRITE( LOGDEV,94030 )
c    &            'Timestep written to', TRIM( PLAYNAME( N ) ),
c    &            'for date and time', WDATE, WTIME
c           END IF


            DEALLOCATE( STKEM )
            IF ( PT3DFRAC ) THEN
               DEALLOCATE( LFRAC )
               DEALLOCATE( ZPLUM )
            END IF

         END DO   ! NPTGRPS

c        IF ( PT3DDIAG ) THEN  ! store 3d point source emissions
c           NTICS = NTICS + 1
c           IF ( NTICS .LT. TIME2SEC( TSTEP( 1 ) ) / TIME2SEC( TSTEP( 2 ) ) ) THEN
c              VDEMIS_BUF = VDEMIS_BUF + VDEMIS_PT
c              PMEMIS_BUF = PMEMIS_BUF + PMEMIS_PT
c           ELSE
c              DIVFAC = 1.0 / FLOAT( NTICS )
c              DO V = 1, N_SPC_PTEM
c                 VDEMIS_BUF( :,:,:,V ) = DIVFAC
c    &                                  * ( VDEMIS_BUF( :,:,:,V ) + VDEMIS_PT( :,:,:,V ) )
c                 IF ( .NOT. WRITE3( CTM_PT3D_DIAG, STKEM_NAME( V ),
c    &                               WDATE, WTIME, VDEMIS_BUF( :,:,:,V ) ) ) THEN
c                    XMSG = 'Error writing "VDEMIS_PT" to '
c    &                    // CTM_PT3D_DIAG( 1:LEN_TRIM( CTM_PT3D_DIAG ) )
c                    CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
c                 END IF
c              END DO
c              DO V = 1, N_SPC_PTPM
c                 PMEMIS_BUF( :,:,:,V ) = DIVFAC
c    &                                  * ( PMEMIS_BUF( :,:,:,V ) + PMEMIS_PT( :,:,:,V ) )
c                 IF ( .NOT. WRITE3( CTM_PT3D_DIAG, STKPM_NAME( V ),
c    &                               WDATE, WTIME, PMEMIS_BUF( :,:,:,V ) ) ) THEN
c                    XMSG = 'Error writing "PMEMIS_PT" to '
c    &                    // CTM_PT3D_DIAG( 1:LEN_TRIM( CTM_PT3D_DIAG ) )
c                    CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
c                 END IF
c              END DO
c              WRITE( LOGDEV,94030 )
c    &               'Timestep written to', CTM_PT3D_DIAG,
c    &               'for date and time', WDATE, WTIME
c           VDEMIS_BUF = 0.0   ! array
c           PMEMIS_BUF = 0.0   ! array
c           NTICS = 0
c           END IF
c        END IF

         RETURN

C------------------  FORMAT  STATEMENTS   ------------------------------

93000    FORMAT( A / 1X,'source',3X, 'ht', 3X, 'lpbl', 1X, 'lbot', 1X, 'ltop',
     &               3X,'vel',4X,'windspeed', 2X, 'StkTemp', 3X, 'AmbTemp' )

93040    FORMAT( 'Sources with top of plume greater than layer', I3, //,
     &           'Src ID, ', A, ', H[m], ', 'V[m/s], ', 'Ts[K], ',
     &           'Ta[K], ', 'U[m/s], ', 'LPBL, ', 'LTOP' )

93042    FORMAT( '( I6, ",", I6.6, ",", A', I2.2, ', ","', I2.2, '(A',
     &           I2.2, ',", ") , F6.1, ", ", F6.2, ", ", F6.1, ", ",',
     &           'F5.1, ", ", F6.2, ", ", I3, ", ", I3 )' )

93044    FORMAT( I6, ",", I6.6, F6.1, ", ", F6.2, ", ", F6.1, ", ",
     &           F5.1, ", ", F6.2, ", ", I3, ", ", I3 )

93048    FORMAT( I6, F8.2, 3I4, 4F10.2 )

94010    FORMAT( 12( A, :, I8, :, 1X ) )
94020    FORMAT( 10( A, :, I7, :, 1X ) )
94030    FORMAT( /5X, 3( A, :, 1X ), I8, ":", I6.6 )

         END SUBROUTINE GET_S_PT3D_EMIS

C-----------------------------------------------------------------------

      END MODULE S_PT3D_DEFN

